Server‑Side VisualResponse Transformation System

Overview and Goals

In a multi-endpoint MCP Server architecture, raw API responses often vary in structure. The goal is to normalize these into a consistent VisualResponse format on the server side, so the client-side JavaScript SDK can render UI components (cards, tables, detail views, lists, etc.) uniformly. This approach follows a Backend-for-Frontend style: the server acts as a view-model transformer, trimming and shaping data for the front-end’s needs ￼. By doing this transformation server-side, we ensure that:
	•	Consistency: Every endpoint returns data in the same VisualResponse schema, regardless of the original API format.
	•	Simplicity on the Client: The JS SDK can be generic, rendering UIs based on the layout field without custom parsing per endpoint.
	•	Security & Relevance: Only necessary fields are exposed, and extraneous data is dropped (similar to how view-models avoid leaking internal fields ￼).
	•	Performance: Reducing and structuring data on the server can cut down payload size and client processing.

Key Requirements Recap:
	1.	Server-Side Transformation: Raw JSON from each API is converted on the server into a VisualResponse before sending to client.
	2.	Multiple UI Layouts: The format supports different presentation layouts ("card", "table", "detail", "list", etc.), selectable per endpoint or data type.
	3.	LLM-Generated Templates: Each API endpoint is associated with a mapping template (rules to convert its response to VisualResponse), initially generated by an LLM using the endpoint’s OpenAPI spec and example responses.
	4.	Uniform Output Schema: The resulting VisualResponse structure is consistent across all endpoints (same top-level fields), regardless of the input shape.

Proposed VisualResponse Schema (TypeScript)

We define a flexible TypeScript interface to accommodate various layouts while keeping a uniform structure:

type LayoutType = 'card' | 'table' | 'detail' | 'list';

interface VisualResponse {
  layout: LayoutType;
  title?: string;              // Optional overall title for the content set
  items?: VisualItem[];        // List of items (for 'card', 'list', or 'detail' with single-item)
  columns?: ColumnDef[];       // Column definitions (for 'table' layout)
  rows?: RowData[];            // Row entries (for 'table' layout, an array of data objects per row)
  errorMessage?: string;       // Optional error or notice (e.g., if transformation had issues)
}

interface VisualItem {
  title: string;               // Primary text or label for the item
  subtitle?: string;           // Secondary text (e.g. subheading, date, etc.)
  description?: string;        // Longer description or detail (used in 'detail' layout or verbose lists)
  imageUrl?: string;           // URL of an image (used in 'card' layout) 
  linkUrl?: string;            // Click-through link for the item (if applicable)
  // Additional fields can be added as needed for specific layouts or metadata
}

interface ColumnDef {
  field: string;              // Key for the data field (matching keys in rows)
  header: string;             // Human-readable column header
}

interface RowData {
  [key: string]: any;         // Each row is an object with keys matching column fields
}

Schema Explanation: The VisualResponse has a layout type to inform the client how to render it. For card and list layouts, an items array holds multiple VisualItem entries, each with common fields (title, subtitle, etc.). This aligns with typical card UI elements which usually include a title, an image, and a brief description ￼. For a detail view (usually a single item’s full details), we can either use one entry in items (with a richer description or additional fields), or use key/value pairs in VisualItem.description or a similar mechanism to list out attributes. For table layout, we include a columns definition (names and labels) and a parallel array of rows, where each row is an object of key-value pairs corresponding to columns. This schema is kept broad to cover different needs but remains consistent (always encapsulated in a VisualResponse with known fields).

Example: Transforming a Sample API Response

To illustrate, consider the following raw API response (for example, an endpoint returning radio station info):

{
  "data": {
    "data": [
      {
        "name": "Show Radyo 2",
        "stream_link": "https://www.showradyo.com.tr",
        "logo": {
          "url": "https://fsn1.your-objectstorage.com/.../wallpaper2-IYbpFt3B.jpg"
        },
        "created_at": "2025-07-01T12:26:41.000000Z"
      }
    ]
  }
}

Using the server-side template for this endpoint, the VisualResponse might be produced as:

{
  "layout": "card",
  "items": [
    {
      "title": "Show Radyo 2",
      "subtitle": "Created on 2025-07-01",
      "imageUrl": "https://fsn1.your-objectstorage.com/.../wallpaper2-IYbpFt3B.jpg",
      "linkUrl": "https://www.showradyo.com.tr"
    }
  ]
}

Explanation: In this example, the transformation chose a card layout because the data represents an item with an image and title (a common use-case for a card). The mapping template pulled name as the card title, the logo.url as imageUrl, and the stream_link as a linkUrl (so the card could be clickable). The created_at field was reformatted and placed into the subtitle (as an example; the template might format dates as needed). If multiple items were present, each would appear as a separate entry in the items array. The client SDK, seeing layout: "card", would render each item as a card with the given image and texts. If the layout were "list", perhaps the transformation would omit the image and only provide titles (and maybe subtitles) in a simpler list form. If it were "table", the output might instead include columns like Name, Stream Link, Created At and corresponding rows. The key is that regardless of the original JSON structure, the output follows the uniform schema so the frontend can handle it generically.

Architecture: Template Storage and Application

Template Repository: Each API endpoint is associated with a mapping template that defines how to convert that endpoint’s raw response to the VisualResponse. These templates can be stored in a structured way, for example:
	•	In Code: as predefined mapping objects or functions in the server repository.
	•	In Configuration: as JSON/YAML files or database records, keyed by endpoint name or URL (allowing updates without code changes).
	•	Via Registry: possibly tied to the OpenAPI spec (e.g., using the operation ID or path as the key).

A template itself can be represented in a JSON-based DSL or a small script. The template essentially describes which fields from the input map to which fields in the output. For example, a template might look like:

// Pseudo-template example for the radio station endpoint
{
  "layout": "card",
  "mappings": {
    "items": "$.data.data",                // JSONPath to the list of items in input
    "title": "$.name",                     // within each item, use 'name' as title
    "subtitle": "$.created_at",            // use 'created_at' (could add date formatting rules)
    "imageUrl": "$.logo.url",              // use nested logo.url
    "linkUrl": "$.stream_link"             // use stream_link for clickable link
  }
}

In this pseudo-template, JSONPath syntax (or similar) is used to locate data in the input JSON. Using JSONPath or JMESPath expressions within a template is a common technique to build an output JSON from an input JSON ￼. At runtime, the transformation engine would evaluate these paths against the actual response and construct the VisualResponse accordingly.

Transformation Flow:
	1.	Incoming API Response: The MCP server invokes an internal API or database and receives the raw JSON (responsePayload).
	2.	Identify Template: Based on the endpoint (for instance, by request URL or a route-to-template mapping), the server loads the corresponding mapping template.
	3.	Apply Template: The mapping rules are applied to the responsePayload. This could be done via:
	•	A built-in transformation module that interprets the template (e.g., replacing paths with actual values).
	•	Executing a function or script associated with the template (for complex transformations).
	•	Using a library or DSL: e.g., a JSON transformation library where the template says output keys and input paths, possibly with minor formatting callbacks. (This is analogous to AWS API Gateway’s mapping templates which use a script with JSON path extraction to reshape data ￼.)
	4.	Produce VisualResponse: The output of the transformation is an object matching the VisualResponse schema. The server then sends this to the client.

Performance and Caching: Templates should be lightweight to apply. We can cache compiled templates or precompute static parts. For example, if using a JavaScript-based template, it could be loaded and evaluated once, then reused for each request. The mapping itself is typically O(n) relative to the size of the data (just extracting and copying fields). By confining transformation logic to the server, we avoid repetitive work on the client side and leverage server resources for any heavy lifting (like date formatting, localization, etc., if needed in templates).

Storage Considerations: Storing templates in a database or config allows updating how data is presented without redeploying code – the LLM could generate new templates and an admin could update them dynamically. However, storing them in code (hardcoded mappings) might be simpler initially and ensures version control. A hybrid approach could be to auto-generate code from templates as part of the build process using the LLM (see next section).

LLM-Generated Mapping Templates

To minimize manual coding, we integrate a Large Language Model (LLM) (such as GPT-4 or similar) into the development workflow for creating and updating mapping templates for each endpoint. The process might look like this:
	1.	Prepare Endpoint Specification: Gather the OpenAPI schema (or MCP interface spec) for the endpoint, especially the response model. Also gather one or more example responses – either from documentation or real samples. This information gives the LLM context about the data structure and semantics (field names, types, meanings).
	2.	Design the Prompt: Construct a prompt that instructs the LLM to output a mapping template. For example:
	•	Provide the endpoint description and the relevant portion of the OpenAPI spec (e.g., the response schema, field descriptions).
	•	Provide a sample JSON response (so the LLM sees actual field values and structure).
	•	Describe the desired VisualResponse schema and possible layouts. For instance: “You are a JSON transformation assistant. We have an API response with the following schema… and example… We want to present this data to users. Choose an appropriate layout (card, table, list, or detail) and generate a mapping template in JSON that maps fields from the input to a VisualResponse with that layout. Include fields like title, subtitle, imageUrl, etc., where appropriate.”
This prompt guides the LLM to infer both the best layout and the field mappings. (For example, if it sees an array of objects with similar fields, it might opt for a table or list; if it sees an image URL field, it might choose a card and map that field to imageUrl; if it’s a single object with many fields, it might choose detail layout to list out all fields.)
	3.	LLM Output (Template Draft): The LLM will produce a draft mapping template. This could be a JSON like the pseudo-template shown earlier, or possibly a snippet of code or pseudo-code. For consistency, we’d ask for a structured output (JSON) that our system can parse. We may need to do slight post-processing – e.g., ensure JSON syntax is correct, fill in any minor gaps, etc.
	4.	Review & Test: A developer should review the LLM-generated template. Key things to verify:
	•	Layout choice makes sense for the data and intended UI. (The developer can override it if needed; e.g., maybe the LLM chose a table but we prefer cards.)
	•	Field mappings are correct (all important information is captured, and irrelevant fields omitted). Field naming in the output should match the VisualResponse schema (e.g., ensure it used title for the main field, etc.).
	•	Transformations: If any formatting or combination is needed (e.g., combining first name + last name into one title string, or formatting a date), the template should handle it or note it. An LLM could generate simple JavaScript expressions or a described rule for formatting which we may embed in the template (or implement via code hooks).
	5.	Iterate if Needed: If the template isn’t perfect, the developer can either edit it manually or refine the prompt and ask the LLM again. This might be needed especially for complex endpoints.
	6.	Integrate into System: Once approved, the template is saved in the template store (database, file, or code). It’s now ready to be applied at runtime for that endpoint. Optionally, unit tests with known input-output pairs can be added to ensure the template works as expected. For example, feed the sample response through the template function and verify it produces the expected VisualResponse.
	7.	Automation Considerations: This LLM-driven process could be interactive (developer runs a script for each new endpoint) or semi-automated: e.g., a CI pipeline that flags new/changed endpoints and generates templates for them. Given that LLM outputs might occasionally err, having a human in the loop is recommended for quality control.

By leveraging an LLM in this manner, we accelerate the creation of view-model mappings that would otherwise be written by hand. The LLM effectively serves as an assistant to suggest how to present data, based on learned patterns (e.g., it “knows” a field named name or title is likely a good candidate for a card title, a field containing URL might be an image or link, etc.). This also enforces consistency; the LLM can be instructed with examples of our VisualResponse format so it uses the same schema across all templates.

Graceful Fallbacks and Error Handling

In a robust system, we must handle situations where a mapping template might be missing or fail to apply:
	•	No Template Found: If a particular endpoint has no mapping template (e.g., a newly added endpoint that we haven’t prepared), the system should fail gracefully. One strategy is to return a generic VisualResponse as a fallback. For example:
	•	Determine if the raw response is a list or single object. If it’s a list of objects with uniform structure, default to a table layout: generate columns from the object’s keys and fill rows with the data. If it’s a single object, default to a detail layout: perhaps produce a single VisualItem where each key-value in the object becomes a line of description.
	•	The fallback VisualResponse could also include an errorMessage like “Unmapped response format” so the client knows this is a basic view.
	•	This way, the client still receives a structured response (it won’t break the rendering logic, even if it’s not tailored). The user might see a raw table of fields, but it’s better than nothing.
	•	For example, the server could detect no template for /newEndpoint and automatically do: layout = 'detail' and put the entire JSON under items[0].description or similar. This would show the raw JSON in a preformatted block on the UI, ensuring something is visible.
	•	Transformation Errors: If a template exists but something goes wrong during transformation (e.g., the input doesn’t match assumptions, or a path is invalid due to a missing field), the system should catch exceptions and not crash. In such cases, it can either:
	•	Log the error: for developers to investigate (including which endpoint and perhaps a snippet of the response that failed).
	•	Fallback to Raw: Similar to no template, return a minimal VisualResponse that perhaps encapsulates the raw data. Possibly use a "detail" layout with a single item that contains a JSON string of the raw response or a simple key-value listing. And include an errorMessage field to inform that this is a fallback.
	•	Optionally, an alert/monitoring could be triggered so that developers know a template might need updating (for instance, the API response changed and the template didn’t account for it).
	•	LLM Generation Failures: If the attempt to generate a template via LLM fails (e.g., API call error or the LLM returns unusable output), the pipeline should handle it gracefully. This might just surface to the developer (since LLM integration is likely an offline process), but if it were automated, the system could either retry or mark that endpoint as requiring manual attention.

The principle is similar to how AWS API Gateway handles unmapped payloads: if no mapping template is defined for a given content type, the data just passes through unchanged by default ￼. We adapt that idea: our default behavior without a template is to pass through the data, but still wrapped in a basic VisualResponse format. This ensures the frontend isn’t dealing with completely raw data (maintaining the contract of a uniform structure), albeit the presentation might be generic.

System Architecture Summary

To summarize how all pieces tie together:
	•	Template Definition: Initially created by an LLM + developer, stored in a template repository. Each template knows the endpoint (or response type) it applies to and the output layout/field mappings.
	•	Server Middleware: A response-mapping middleware in the MCP server intercepts outgoing responses. It looks up the current endpoint’s template and invokes the transformation. This could happen after the main business logic/controller gets the raw data but before sending to the client.
	•	Transformation Engine: The component (function or class) that applies templates. It can interpret JSONPath expressions or execute small scripts. It must be robust against missing data. Complex logic (if needed) can be handled here too (e.g., conditional formatting: if a value is above a threshold, maybe add a flag – such rules could be coded into the template or in the engine).
	•	Client SDK: The client-side JavaScript SDK simply takes the VisualResponse. Based on the layout field, it routes to the appropriate renderer:
	•	For layout: "card", it might loop through items and render a card component for each (image on top, title, subtitle, etc.).
	•	For layout: "table", it might render an HTML table or data grid using columns and rows.
	•	For layout: "detail", perhaps render a definition list or a series of field labels and values.
	•	For layout: "list", a simple list of text items or links.
This SDK layer is beyond the server, but it benefits from the server’s work by being generic and configuration-driven, rather than containing custom logic per endpoint.
	•	Maintenance Loop: When APIs evolve (new fields, renamed fields, etc.), templates should be updated. The team can invoke the LLM assistant to regenerate or edit the template, then deploy the update. Monitoring and user feedback can also inform if a particular VisualResponse isn’t useful, prompting a redesign of that template.

By implementing this server-side transformation system, the MCP server ensures a clean separation of concerns: backend services provide data, the MCP layer standardizes and formats it for presentation, and the frontend simply renders it. This leads to a more maintainable codebase and a better developer experience on the front-end side, since they work with one predictable response format across all calls. It also opens up the possibility for dynamic UI changes (since changing a template on the server can instantly alter how data is shown, without a client app update).

Overall, this design brings flexibility and uniformity, leveraging AI (LLMs) to speed up template creation, and providing safe fallbacks to handle the unexpected gracefully. The result is a robust system where any API’s output can be plugged into the front-end’s visual components with minimal custom effort, fulfilling the promise of a truly consistent VisualResponse interface across the application.

Sources: The approach takes inspiration from the backend-for-frontend pattern and view model transformation best practices ￼. Card and table layouts are defined per common UI/UX guidelines (cards typically contain titles, images, etc. ￼). The concept of using JSONPath in templates is analogous to templating systems like AWS API Gateway’s mapping templates and other JSON transform tools ￼. In absence of a specific mapping, passing data through by default (or with a generic wrapper) is recommended to avoid breaking clients ￼. This ensures the system is both powerful (through customization) and resilient (through safe defaults).\n## Frontend SDK\n\nThe repository now includes a `frontend` directory containing a React + TypeScript SDK for embedding the MCP chatbot. See `frontend/README.md` for usage.
